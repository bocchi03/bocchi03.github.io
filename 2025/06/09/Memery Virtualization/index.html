<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="bocchi">





<title>Memery Virtualization | my-Blog</title>



    <link rel="icon" href="/notebook.ico">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    



    
    
        
    


<meta name="generator" content="Hexo 7.3.0"></head>

<body>
    <script>
        // this function is used to check current theme before page loaded.
        (() => {
            const pagebody = document.getElementsByTagName('body')[0]

            function setTheme(status) {

                if (status === 'dark') {
                    window.sessionStorage.theme = 'dark'
                    pagebody.classList.add('dark-theme');

                } else if (status === 'light') {
                    window.sessionStorage.theme = 'light'
                    pagebody.classList.remove('dark-theme');
                }
            };

            setTheme(window.sessionStorage.theme)
        })();
    </script>

    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">Blog</a></div>
            <div class="menu navbar-right">
                
                <a class="menu-item" href="/archives">Posts</a>
                
                <a class="menu-item" href="/category">Categories</a>
                
                <a class="menu-item" href="/tag">Tags</a>
                
                <a class="menu-item" href="/about">About</a>
                
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>
        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">Blog</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">
                    <svg class="menu-icon" xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="currentColor" d="M4.5 17.27q-.213 0-.356-.145T4 16.768t.144-.356t.356-.143h15q.213 0 .356.144q.144.144.144.357t-.144.356t-.356.143zm0-4.77q-.213 0-.356-.144T4 11.999t.144-.356t.356-.143h15q.213 0 .356.144t.144.357t-.144.356t-.356.143zm0-4.77q-.213 0-.356-.143Q4 7.443 4 7.23t.144-.356t.356-.143h15q.213 0 .356.144T20 7.23t-.144.356t-.356.144z"/></svg>
                    <svg class="close-icon" xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><!-- Icon from Material Symbols Light by Google - https://github.com/google/material-design-icons/blob/master/LICENSE --><path fill="currentColor" d="m12 12.708l-5.246 5.246q-.14.14-.344.15t-.364-.15t-.16-.354t.16-.354L11.292 12L6.046 6.754q-.14-.14-.15-.344t.15-.364t.354-.16t.354.16L12 11.292l5.246-5.246q.14-.14.345-.15q.203-.01.363.15t.16.354t-.16.354L12.708 12l5.246 5.246q.14.14.15.345q.01.203-.15.363t-.354.16t-.354-.16z"/></svg>
                </div>
            </div>
            <div class="menu" id="mobile-menu">
                
                <a class="menu-item" href="/archives">Posts</a>
                
                <a class="menu-item" href="/category">Categories</a>
                
                <a class="menu-item" href="/tag">Tags</a>
                
                <a class="menu-item" href="/about">About</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if (toggleMenu.classList.contains("active")) {
            toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        } else {
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
            <div class="main">
                <div class="container">
    
    
        <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">Expand all</a>
        <a onclick="go_top()">Back to top</a>
        <a onclick="go_bottom()">Go to bottom</a>
    </div>
</div>

<script>
    var tocbot_timer;
    var DEPTH_MAX = 6; // 为 6 时展开所有
    var tocbot_default_config = {
        tocSelector: '.tocbot-list',
        contentSelector: '.post-content',
        headingSelector: 'h1, h2, h3, h4, h5',
        orderedList: false,
        scrollSmooth: true,
        onClick: extend_click,
    };

    function extend_click() {
        clearTimeout(tocbot_timer);
        tocbot_timer = setTimeout(function() {
            tocbot.refresh(obj_merge(tocbot_default_config, {
                hasInnerContainers: true
            }));
        }, 420); // 这个值是由 tocbot 源码里定义的 scrollSmoothDuration 得来的
    }

    document.ready(function() {
        tocbot.init(obj_merge(tocbot_default_config, {
            collapseDepth: 1
        }));
    });

    function expand_toc() {
        var b = document.querySelector('.tocbot-toc-expand');
        var expanded = b.getAttribute('data-expanded');
        expanded ? b.removeAttribute('data-expanded') : b.setAttribute('data-expanded', true);
        tocbot.refresh(obj_merge(tocbot_default_config, {
            collapseDepth: expanded ? 1 : DEPTH_MAX
        }));
        b.innerText = expanded ? 'Expand all' : 'Collapse all';
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

    function obj_merge(target, source) {
        for (var item in source) {
            if (source.hasOwnProperty(item)) {
                target[item] = source[item];
            }
        }
        return target;
    }
</script>
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">Memery Virtualization</h1>
            
                <div class="post-meta">
                    
                        Author: <a itemprop="author" rel="author" href="/">bocchi</a>
                    

                    
                        <span class="post-time">
                        Date: <a href="#">June 9, 2025&nbsp;&nbsp;19:17:25</a>
                        </span>
                    
                    
                        <span class="post-category">
                    Category:
                            
                                <a href="/categories/408/">408</a>
                            
                        </span>
                    
                </div>
            
        </header>

        <div class="post-content">
            <h1 id="Operating-Systems-Three-Easy-Pieces-内存虚拟化笔记（第-12-24-章）"><a href="#Operating-Systems-Three-Easy-Pieces-内存虚拟化笔记（第-12-24-章）" class="headerlink" title="Operating Systems: Three Easy Pieces - 内存虚拟化笔记（第 12-24 章）"></a><strong>Operating Systems: Three Easy Pieces - 内存虚拟化笔记（第 12-24 章）</strong></h1><h2 id="第-12-章-关于内存虚拟化的对话"><a href="#第-12-章-关于内存虚拟化的对话" class="headerlink" title="第 12 章 关于内存虚拟化的对话"></a><strong>第 12 章 关于内存虚拟化的对话</strong></h2><h3 id="内容概述"><a href="#内容概述" class="headerlink" title="内容概述"></a><strong>内容概述</strong></h3><p>本章通过对话形式介绍了内存虚拟化的基本概念和重要性。内存虚拟化是现代操作系统的核心特性，为每个进程提供一个独立的虚拟地址空间，使其感觉独占整个物理内存。这种抽象通过硬件（内存管理单元 MMU）和软件（操作系统）的协作实现，带来了隔离性、高效性和灵活性。</p>
<h3 id="详细说明"><a href="#详细说明" class="headerlink" title="详细说明"></a><strong>详细说明</strong></h3><ul>
<li><strong>隔离性</strong>：虚拟内存确保进程间内存操作互不干扰。例如，进程 A 无法访问进程 B 的内存区域，防止数据损坏或安全漏洞。硬件通过权限检查（如读&#x2F;写保护）实现隔离。</li>
<li><strong>高效性</strong>：虚拟内存支持多道程序设计（多个程序同时驻留内存）和时分共享（快速切换进程），提高 CPU 和内存利用率。例如，通过分页和交换技术，系统可以在物理内存不足时将数据移到磁盘，支持运行超出物理内存的程序。</li>
<li><strong>灵活性</strong>：程序员无需关心物理内存的分配细节。例如，程序使用连续的虚拟地址（如 0x1000 到 0x2000），操作系统自动映射到分散的物理内存位置。这种透明性简化了开发，提高了代码可移植性。</li>
<li><strong>实际应用</strong>：虚拟内存广泛应用于 Linux、Windows 等系统。例如，运行多个应用程序（如浏览器和文本编辑器）时，每个应用程序认为自己拥有独立的内存空间，而操作系统在后台管理资源分配。</li>
<li><strong>挑战</strong>：虚拟内存引入了性能开销（如页表查询和页面交换），需要优化硬件（如 TLB）和算法（如页面替换）来平衡效率和功能。</li>
</ul>
<hr>
<h2 id="第-13-章-抽象：地址空间"><a href="#第-13-章-抽象：地址空间" class="headerlink" title="第 13 章 抽象：地址空间"></a><strong>第 13 章 抽象：地址空间</strong></h2><h3 id="13-1-早期系统"><a href="#13-1-早期系统" class="headerlink" title="13.1 早期系统"></a><strong>13.1 早期系统</strong></h3><h4 id="描述"><a href="#描述" class="headerlink" title="描述"></a><strong>描述</strong></h4><p>早期计算机没有虚拟内存，程序直接操作物理内存地址。</p>
<p><img src="/../image/image-20250504200807682.png" alt="image-20250504200807682"></p>
<h4 id="详细说明-1"><a href="#详细说明-1" class="headerlink" title="详细说明"></a><strong>详细说明</strong></h4><ul>
<li><strong>机制</strong>：程序加载到固定或动态分配的物理内存地址。例如，程序 A 可能加载到 0x1000，程序 B 加载到 0x2000。</li>
<li><strong>问题</strong>：<ul>
<li><strong>内存碎片</strong>：程序分配和释放内存后，物理内存出现不连续的空闲块。例如，释放 0x1500-0x2000 的内存后，剩余空闲块可能太小，无法满足新请求。</li>
<li><strong>缺乏保护</strong>：进程之间没有隔离，一个进程可能意外或恶意地覆盖另一个进程的内存。例如，程序 A 写入 0x2000 会破坏程序 B 的数据，导致崩溃或安全漏洞。</li>
</ul>
</li>
<li><strong>挑战</strong>：操作系统需手动管理内存分配和保护，例如通过记录每个程序的内存范围，但这种方法效率低且在多任务环境下容易出错。</li>
<li><strong>实际应用</strong>：早期批处理系统（如 IBM 360）使用这种直接访问方式，限制了并发能力。</li>
</ul>
<h3 id="13-2-多道程序和时分共享"><a href="#13-2-多道程序和时分共享" class="headerlink" title="13.2 多道程序和时分共享"></a><strong>13.2 多道程序和时分共享</strong></h3><h4 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a><strong>描述</strong></h4><ul>
<li><strong>多道程序</strong>：允许多个程序同时驻留内存，当一个程序等待 I&#x2F;O 时，CPU 执行其他程序。</li>
<li><strong>时分共享</strong>：通过快速切换进程，为用户 Polling (Round-Robin) 调度实现交互式体验。</li>
</ul>
<h4 id="详细说明-2"><a href="#详细说明-2" class="headerlink" title="详细说明"></a><strong>详细说明</strong></h4><ul>
<li><strong>多道程序</strong>：提高了 CPU 利用率。例如，程序 A 等待磁盘读取时，CPU 可以运行程序 B。这种机制需要内存管理来确保程序的内存区域不重叠。</li>
<li><strong>时分共享</strong>：通过调度算法（如轮转调度），操作系统在短时间内（例如 10 毫秒）切换进程，用户感觉独占机器。例如，多个用户通过终端登录服务器，共享 CPU。</li>
<li><strong>挑战</strong>：需要高效的内存隔离机制（如基址&#x2F;界限寄存器）以防止进程干扰，同时优化内存分配以支持更多程序。</li>
<li><strong>实际应用</strong>：Unix 和早期 minicomputers（如 PDP-11）采用时分共享，支持多用户交互。</li>
</ul>
<h3 id="13-3-地址空间的目标"><a href="#13-3-地址空间的目标" class="headerlink" title="13.3 地址空间的目标"></a><strong>13.3 地址空间的目标</strong></h3><h4 id="描述-2"><a href="#描述-2" class="headerlink" title="描述"></a><strong>描述</strong></h4><p>地址空间的目标包括：</p>
<ul>
<li><strong>透明性</strong>：程序员无需了解物理内存布局。</li>
<li><strong>效率</strong>：最大化 CPU 和内存资源使用。</li>
<li><strong>保护</strong>：防止进程间非法访问。</li>
</ul>
<h4 id="详细说明-3"><a href="#详细说明-3" class="headerlink" title="详细说明"></a><strong>详细说明</strong></h4><ul>
<li><strong>透明性</strong>：程序使用虚拟地址（如 0x1000），操作系统通过页表或段表转换为物理地址（如 0x5000）。例如，C 程序的指针操作基于虚拟地址，无需关心物理内存。</li>
<li><strong>效率</strong>：虚拟内存通过分页（固定大小页面）和交换（将不活跃页面移到磁盘）支持运行超出物理内存的程序。例如，1GB 物理内存可运行 2GB 程序。</li>
<li><strong>保护</strong>：硬件（如 MMU）通过权限位（读、写、执行）确保进程只能访问自己的地址空间。例如，试图写入只读页面会触发异常。</li>
<li><strong>实际 application</strong>：Linux 使用独立的地址空间支持数百个进程，保护用户数据和系统稳定性。</li>
</ul>
<p><img src="/../image/image-20250504201157706.png" alt="image-20250504201157706"></p>
<h3 id="13-4-小结"><a href="#13-4-小结" class="headerlink" title="13.4 小结"></a><strong>13.4 小结</strong></h3><p>地址空间抽象为操作系统提供了实现透明性、效率和保护的基础。它简化了程序开发，提高了资源利用率。例如，现代操作系统通过地址空间支持复杂的多任务环境，而无需程序员手动管理内存。</p>
<hr>
<h2 id="第-14-章-插叙：内存操作-API"><a href="#第-14-章-插叙：内存操作-API" class="headerlink" title="第 14 章 插叙：内存操作 API"></a><strong>第 14 章 插叙：内存操作 API</strong></h2><h3 id="14-1-内存类型"><a href="#14-1-内存类型" class="headerlink" title="14.1 内存类型"></a><strong>14.1 内存类型</strong></h3><h4 id="描述-3"><a href="#描述-3" class="headerlink" title="描述"></a><strong>描述</strong></h4><ul>
<li><strong>栈内存</strong>：系统自动管理，用于局部变量和函数调用。</li>
<li><strong>堆内存</strong>：程序员手动管理，用于动态分配。</li>
</ul>
<h4 id="详细说明-4"><a href="#详细说明-4" class="headerlink" title="详细说明"></a><strong>详细说明</strong></h4><ul>
<li><p><strong>栈内存</strong>：遵循后进先出（LIFO）原则。函数调用时分配栈帧（局部变量、返回地址），返回时自动释放。栈大小有限（例如 Linux 默认 8MB）。</p>
<ul>
<li><strong>示例</strong>：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">10</span>; <span class="comment">// 栈上分配</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>堆内存</strong>：通过 API（如 <code>malloc()</code> 和 <code>free()</code>）分配，生命周期由程序员控制。适合动态数据结构（如链表、数组）。</p>
<ul>
<li><strong>示例</strong>：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *arr = <span class="built_in">malloc</span>(<span class="number">10</span> * <span class="keyword">sizeof</span>(<span class="type">int</span>)); <span class="comment">// 堆上分配</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>挑战</strong>：栈溢出（递归过深）和堆内存泄漏是常见问题。</p>
</li>
</ul>
<h3 id="14-2-malloc-调用"><a href="#14-2-malloc-调用" class="headerlink" title="14.2 malloc() 调用"></a><strong>14.2 <code>malloc()</code> 调用</strong></h3><h4 id="描述-4"><a href="#描述-4" class="headerlink" title="描述"></a><strong>描述</strong></h4><p><code>malloc()</code> 从堆中分配指定大小的内存块。</p>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a><strong>示例</strong></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *ptr = <span class="built_in">malloc</span>(<span class="number">10</span> * <span class="keyword">sizeof</span>(<span class="type">int</span>)); <span class="comment">// 分配 40 字节（假设 int 为 4 字节）</span></span><br></pre></td></tr></table></figure>

<h4 id="详细说明-5"><a href="#详细说明-5" class="headerlink" title="详细说明"></a><strong>详细说明</strong></h4><ul>
<li><p><strong>机制</strong>：<code>malloc()</code> 返回虚拟地址，操作系统将其映射到物理内存。如果堆空间不足，操作系统通过 <code>sbrk</code> 或 <code>mmap</code> 系统调用扩展堆。</p>
</li>
<li><p><strong>注意</strong>：分配失败返回 <code>NULL</code>，需检查返回值。例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (ptr == <span class="literal">NULL</span>) &#123; <span class="built_in">printf</span>(<span class="string">&quot;内存分配失败\n&quot;</span>); <span class="built_in">exit</span>(<span class="number">1</span>); &#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>实际应用</strong>：<code>malloc()</code> 用于动态数组、结构体等。例如，Web 服务器动态分配请求缓冲区。</p>
</li>
<li><p><strong>挑战</strong>：频繁分配可能导致碎片，影响性能。</p>
</li>
</ul>
<h3 id="14-3-free-调用"><a href="#14-3-free-调用" class="headerlink" title="14.3 free() 调用"></a><strong>14.3 <code>free()</code> 调用</strong></h3><h4 id="描述-5"><a href="#描述-5" class="headerlink" title="描述"></a><strong>描述</strong></h4><p><code>free()</code> 释放通过 <code>malloc()</code> 分配的内存。</p>
<h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a><strong>示例</strong></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">free</span>(ptr); <span class="comment">// 释放 ptr 指向的内存</span></span><br></pre></td></tr></table></figure>

<h4 id="详细说明-6"><a href="#详细说明-6" class="headerlink" title="详细说明"></a><strong>详细说明</strong></h4><ul>
<li><strong>机制</strong>：通知操作系统内存可重用，更新空闲列表。<code>ptr</code> 值不变，建议置为 <code>NULL</code> 避免野指针。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">free</span>(ptr);</span><br><span class="line">ptr = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure></li>
<li><strong>错误</strong>：<ul>
<li>重复释放（如 <code>free(ptr); free(ptr);</code>）导致未定义行为。</li>
<li>使用已释放内存（如 <code>*ptr = 5</code>）可能崩溃。</li>
</ul>
</li>
<li><strong>实际应用</strong>：服务器程序需及时释放内存以支持长时间运行。</li>
</ul>
<h3 id="14-4-常见错误"><a href="#14-4-常见错误" class="headerlink" title="14.4 常见错误"></a><strong>14.4 常见错误</strong></h3><h4 id="描述-6"><a href="#描述-6" class="headerlink" title="描述"></a><strong>描述</strong></h4><ul>
<li><strong>内存泄漏</strong>：分配后未释放内存。</li>
<li><strong>野指针</strong>：使用已释放内存。</li>
<li><strong>缓冲区溢出</strong>：写入超出分配范围。</li>
</ul>
<h4 id="详细说明-7"><a href="#详细说明-7" class="headerlink" title="详细说明"></a><strong>详细说明</strong></h4><ul>
<li><strong>内存泄漏</strong>：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ptr = <span class="built_in">malloc</span>(<span class="number">100</span>);</span><br><span class="line">ptr = <span class="literal">NULL</span>; <span class="comment">// 100 字节泄漏</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>影响</strong>：耗尽内存，长期运行程序（如服务器）受影响。</li>
<li><strong>工具</strong>：Valgrind 可检测泄漏。</li>
</ul>
</li>
<li><strong>野指针</strong>：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">free</span>(ptr);</span><br><span class="line">*ptr = <span class="number">5</span>; <span class="comment">// 未定义行为</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>后果</strong>：可能崩溃或损坏数据。</li>
</ul>
</li>
<li><strong>缓冲区溢出</strong>：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *arr = <span class="built_in">malloc</span>(<span class="number">4</span>);</span><br><span class="line">arr[<span class="number">10</span>] = <span class="number">1</span>; <span class="comment">// 越界写入</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>后果</strong>：破坏堆结构或触发安全漏洞（如栈溢出攻击）。</li>
</ul>
</li>
<li><strong>实际应用</strong>：现代语言（如 Java）通过垃圾回收避免这些错误，但 C&#x2F;C++ 需手动管理。</li>
</ul>
<h3 id="14-5-底层操作系统支持"><a href="#14-5-底层操作系统支持" class="headerlink" title="14.5 底层操作系统支持"></a><strong>14.5 底层操作系统支持</strong></h3><h4 id="描述-7"><a href="#描述-7" class="headerlink" title="描述"></a><strong>描述</strong></h4><ul>
<li><strong>brk 和 sbrk</strong>：调整堆大小。</li>
<li><strong>mmap</strong>：映射文件或匿名内存。</li>
</ul>
<h4 id="详细说明-8"><a href="#详细说明-8" class="headerlink" title="详细说明"></a><strong>详细说明</strong></h4><ul>
<li><strong>brk</strong>：设置堆结束地址。例如，<code>brk(new_end)</code> 扩展堆到 <code>new_end</code>。</li>
<li><strong>sbrk</strong>：增减堆大小。例如，<code>sbrk(4096)</code> 增加 4KB。</li>
<li><strong>mmap</strong>：分配大块内存或共享内存。例如：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *ptr = mmap(<span class="literal">NULL</span>, <span class="number">4096</span>, PROT_READ|PROT_WRITE, MAP_ANON|MAP_PRIVATE, <span class="number">-1</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure></li>
<li><strong>实际应用</strong>：Linux 内核使用 <code>mmap</code> 分配用户空间内存，<code>sbrk</code> 较少使用。</li>
</ul>
<h3 id="14-6-其他调用"><a href="#14-6-其他调用" class="headerlink" title="14.6 其他调用"></a><strong>14.6 其他调用</strong></h3><h4 id="描述-8"><a href="#描述-8" class="headerlink" title="描述"></a><strong>描述</strong></h4><ul>
<li><strong>calloc</strong>：分配并初始化为零。</li>
<li><strong>realloc</strong>：调整已分配内存大小。</li>
</ul>
<h4 id="详细说明-9"><a href="#详细说明-9" class="headerlink" title="详细说明"></a><strong>详细说明</strong></h4><ul>
<li><strong>calloc</strong>：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *ptr = <span class="built_in">calloc</span>(<span class="number">10</span>, <span class="keyword">sizeof</span>(<span class="type">int</span>)); <span class="comment">// 分配并清零</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>优势</strong>：确保内存初始化，适合安全敏感场景。</li>
</ul>
</li>
<li><strong>realloc</strong>：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ptr = <span class="built_in">realloc</span>(ptr, <span class="number">20</span> * <span class="keyword">sizeof</span>(<span class="type">int</span>)); <span class="comment">// 扩展到 20 个整数</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>机制</strong>：可能移动内存块，需更新指针。</li>
<li><strong>注意</strong>：失败返回 <code>NULL</code>，需检查。</li>
</ul>
</li>
<li><strong>实际应用</strong>：<code>realloc</code> 用于动态数组扩展，如处理可变长度输入。</li>
</ul>
<h3 id="14-7-小结"><a href="#14-7-小结" class="headerlink" title="14.7 小结"></a><strong>14.7 小结</strong></h3><p>内存操作 API 是用户与虚拟内存交互的关键。正确使用（如检查返回值、避免泄漏）对程序稳定性至关重要。例如，数据库系统需高效管理内存以支持高并发。</p>
<p><strong>思考问题</strong>：</p>
<ul>
<li>如何检测和修复内存泄漏？</li>
<li>垃圾回收与手动内存管理相比有何优劣？</li>
</ul>
<p><strong>参考资料</strong>：</p>
<ul>
<li>《C Programming Language》 by Kernighan &amp; Ritchie。</li>
<li>Valgrind 文档。</li>
</ul>
<hr>
<h2 id="第-15-章-机制：地址转换"><a href="#第-15-章-机制：地址转换" class="headerlink" title="第 15 章 机制：地址转换"></a><strong>第 15 章 机制：地址转换</strong></h2><h3 id="15-1-假设"><a href="#15-1-假设" class="headerlink" title="15.1 假设"></a><strong>15.1 假设</strong></h3><h4 id="描述-9"><a href="#描述-9" class="headerlink" title="描述"></a><strong>描述</strong></h4><ul>
<li><strong>虚拟地址</strong>：进程使用的逻辑地址。</li>
<li><strong>物理地址</strong>：实际硬件内存地址.</li>
<li><strong>地址转换</strong>：将虚拟地址映射到物理地址。</li>
</ul>
<h4 id="详细说明-10"><a href="#详细说明-10" class="headerlink" title="详细说明"></a><strong>详细说明</strong></h4><ul>
<li><strong>虚拟地址</strong>：由程序生成，如指针地址（<code>&amp;x</code>）。例如，<code>0x1000</code> 是虚拟地址。</li>
<li><strong>物理地址</strong>：硬件访问的实际内存位置。例如，<code>0x5000</code> 是物理地址。</li>
<li><strong>机制</strong>：MMU（内存管理单元）通过页表或段表完成转换。</li>
<li><strong>目的</strong>：实现隔离（进程独立地址空间）和优化（非连续内存分配）。</li>
<li><strong>实际 application</strong>：Linux 使用分页，每个进程有独立虚拟地址空间。</li>
</ul>
<h3 id="15-2-一个例子"><a href="#15-2-一个例子" class="headerlink" title="15.2 一个例子"></a><strong>15.2 一个例子</strong></h3><h4 id="描述-10"><a href="#描述-10" class="headerlink" title="描述"></a><strong>描述</strong></h4><p>虚拟地址 <code>0x1000</code> 可能映射到物理地址 <code>0x2000</code>.</p>
<h4 id="详细说明-11"><a href="#详细说明-11" class="headerlink" title="详细说明"></a><strong>详细说明</strong></h4><ul>
<li><strong>机制</strong>：假设页面大小 4KB，虚拟地址 <code>0x1000</code> 的页号为 1，偏移为 0。页表将虚拟页 1 映射到物理页 2（地址 <code>0x2000</code>）。</li>
<li><strong>示例</strong>：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x; <span class="comment">// 虚拟地址 0x1000</span></span><br><span class="line">x = <span class="number">5</span>; <span class="comment">// MMU 转换为物理地址 0x2000</span></span><br></pre></td></tr></table></figure></li>
<li><strong>挑战</strong>：每次内存访问需转换，增加延迟，需 TLB 优化。</li>
</ul>
<p><img src="/../image/image-20250504202627068.png" alt="image-20250504202627068"></p>
<h3 id="15-3-动态（基于硬件）重定位"><a href="#15-3-动态（基于硬件）重定位" class="headerlink" title="15.3 动态（基于硬件）重定位"></a><strong>15.3 动态（基于硬件）重定位</strong></h3><h4 id="描述-11"><a href="#描述-11" class="headerlink" title="描述"></a><strong>描述</strong></h4><p>通过基址寄存器和界限寄存器完成地址转换。</p>
<h4 id="公式"><a href="#公式" class="headerlink" title="公式"></a><strong>公式</strong></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">物理地址 = 虚拟地址 + 基址寄存器值（若 虚拟地址 &lt; 界限寄存器值）</span><br></pre></td></tr></table></figure>

<h4 id="详细说明-12"><a href="#详细说明-12" class="headerlink" title="详细说明"></a><strong>详细说明</strong></h4><ul>
<li><strong>基址寄存器</strong>：存储进程地址空间在物理内存的起始地址。例如，基址 <code>0x4000</code>，虚拟地址 <code>0x1000</code> 转换为 <code>0x5000</code>.</li>
<li><strong>界限寄存器</strong>：限制访问范围。例如，界限 <code>0x2000</code>，虚拟地址 <code>0x3000</code> 触发越界异常。</li>
<li><strong>硬件支持</strong>：MMU 检查虚拟地址合法性，转换地址。</li>
<li><strong>局限</strong>：要求连续内存分配，易产生碎片，不适用于现代系统。</li>
<li><strong>实际 application</strong>：早期系统（如 PDP-8）使用重定位，现代系统用分页。</li>
</ul>
<p><img src="/../image/image-20250506190831373.png" alt="image-20250506190831373"></p>
<h3 id="15-4-硬件支持：总结"><a href="#15-4-硬件支持：总结" class="headerlink" title="15.4 硬件支持：总结"></a><strong>15.4 硬件支持：总结</strong></h3><h4 id="描述-12"><a href="#描述-12" class="headerlink" title="描述"></a><strong>描述</strong></h4><ul>
<li><strong>MMU</strong>：负责实时地址转换。</li>
<li><strong>保护位</strong>：限制非法访问。</li>
</ul>
<h4 id="详细说明-13"><a href="#详细说明-13" class="headerlink" title="详细说明"></a><strong>详细说明</strong></h4><ul>
<li><strong>MMU</strong>：集成在 CPU 中，解析虚拟地址，查页表。例如，Intel x86 MMU 使用 CR3 寄存器指向页表。</li>
<li><strong>保护位</strong>：包括读、写、执行权限。例如，试图写入只读页面触发异常。</li>
<li><strong>实际 application</strong>：ARM 和 x86 架构的 MMU 支持多级页表和权限检查。</li>
</ul>
<p><img src="/../image/image-20250506191002250.png" alt="image-20250506191002250"></p>
<h3 id="15-5-操作系统的问题"><a href="#15-5-操作系统的问题" class="headerlink" title="15.5 操作系统的问题"></a><strong>15.5 操作系统的问题</strong></h3><h4 id="描述-13"><a href="#描述-13" class="headerlink" title="描述"></a><strong>描述</strong></h4><ul>
<li><strong>管理空闲空间</strong>：跟踪和分配未使用内存。</li>
<li><strong>保护进程</strong>：确保隔离。</li>
</ul>
<h4 id="详细说明-14"><a href="#详细说明-14" class="headerlink" title="详细说明"></a><strong>详细说明</strong></h4><ul>
<li><strong>空闲空间</strong>：使用位图或空闲列表。例如，位图中 <code>1</code> 表示已分配，<code>0</code> 表示空闲。</li>
<li><strong>保护</strong>：通过页表权限和独立地址空间实现。例如，进程 A 和 B 的页表互不重叠。</li>
<li><strong>挑战</strong>：分配效率和碎片管理影响性能。</li>
</ul>
<p><img src="/../image/image-20250506191157416.png" alt="image-20250506191157416"></p>
<h3 id="15-6-小结"><a href="#15-6-小结" class="headerlink" title="15.6 小结"></a><strong>15.6 小结</strong></h3><p>地址转换是虚拟内存的核心，依赖硬件（如 MMU）和操作系统协作。优化（如 TLB 和多级页表）显著提升性能。例如，现代 CPU 的 TLB 缓存减少了页表查询延迟。</p>
<p><strong>思考问题</strong>：</p>
<ul>
<li>基址&#x2F;界限机制为何被分页取代？</li>
<li>地址转换如何影响实时系统？</li>
</ul>
<p><strong>参考资料</strong>：</p>
<ul>
<li>Intel x86 架构手册（MMU 和分页）。</li>
<li>Linux 内核内存管理文档。</li>
</ul>
<hr>
<h2 id="第-16-章-分段"><a href="#第-16-章-分段" class="headerlink" title="第 16 章 分段"></a><strong>第 16 章 分段</strong></h2><h3 id="16-1-分段：泛化的基址-界限"><a href="#16-1-分段：泛化的基址-界限" class="headerlink" title="16.1 分段：泛化的基址&#x2F;界限"></a><strong>16.1 分段：泛化的基址&#x2F;界限</strong></h3><h4 id="描述-14"><a href="#描述-14" class="headerlink" title="描述"></a><strong>描述</strong></h4><p>分段将地址空间划分为逻辑段（如代码段、数据段、栈段），支持非连续内存分配。</p>
<h4 id="详细说明-15"><a href="#详细说明-15" class="headerlink" title="详细说明"></a><strong>详细说明</strong></h4><ul>
<li><strong>机制</strong>：每个段有独立的基址和界限寄存器。例如，代码段基址 <code>0x1000</code>，界限 <code>0x1000</code>。</li>
<li><strong>优势</strong>：<ul>
<li>灵活性：段可独立分配和增长。</li>
<li>减少外部碎片：非连续分配。</li>
</ul>
</li>
<li><strong>局限</strong>：仍可能产生外部碎片，需内存整理。</li>
<li><strong>实际 application</strong>：x86 早期使用分段（如实模式），现多用分页。</li>
</ul>
<p><img src="/../image/image-20250506191454845.png" alt="image-20250506191454845"></p>
<p><img src="/../image/image-20250506191513655.png" alt="image-20250506191513655"></p>
<h3 id="16-2-我们引用哪个段"><a href="#16-2-我们引用哪个段" class="headerlink" title="16.2 我们引用哪个段"></a><strong>16.2 我们引用哪个段</strong></h3><h4 id="描述-15"><a href="#描述-15" class="headerlink" title="描述"></a><strong>描述</strong></h4><ul>
<li><strong>段寄存器</strong>：指示当前段。</li>
<li><strong>地址格式</strong>：<code>段号 + 偏移量</code>.</li>
</ul>
<h4 id="详细说明-16"><a href="#详细说明-16" class="headerlink" title="详细说明"></a><strong>详细说明</strong></h4><ul>
<li><p><strong>机制</strong>：虚拟地址分为段号和偏移。例如，<code>0x021000</code> 表示段 2 偏移 <code>0x1000</code>。</p>
</li>
<li><p><strong>转换</strong>：MMU 使用段号查找段表，计算物理地址：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">物理地址 = 段基址 + 偏移（若 偏移 &lt; 界限）</span><br></pre></td></tr></table></figure></li>
<li><p><strong>实际 application</strong>：x86 的段寄存器（如 CS、DS）用于区分代码和数据段。</p>
</li>
</ul>
<h3 id="16-3-栈怎么办"><a href="#16-3-栈怎么办" class="headerlink" title="16.3 栈怎么办"></a><strong>16.3 栈怎么办</strong></h3><h4 id="描述-16"><a href="#描述-16" class="headerlink" title="描述"></a><strong>描述</strong></h4><p>栈段从高地址向低地址增长。</p>
<h4 id="详细说明-17"><a href="#详细说明-17" class="headerlink" title="详细说明"></a><strong>详细说明</strong></h4><ul>
<li><strong>机制</strong>：栈基址为段末尾，界限为起始。例如，基址 <code>0xFFFF</code>，界限 <code>0xF000</code>，栈指针递减。</li>
<li><strong>示例</strong>：函数调用分配栈帧，栈指针减小：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">()</span> &#123; <span class="type">int</span> x; &#125; <span class="comment">// 栈指针减小分配 x</span></span><br></pre></td></tr></table></figure></li>
<li><strong>挑战</strong>：栈溢出需检测（如 Linux 的栈保护）。</li>
</ul>
<p><img src="/../image/image-20250506191704527.png" alt="image-20250506191704527"></p>
<h3 id="16-4-支持共享"><a href="#16-4-支持共享" class="headerlink" title="16.4 支持共享"></a><strong>16.4 支持共享</strong></h3><h4 id="描述-17"><a href="#描述-17" class="headerlink" title="描述"></a><strong>描述</strong></h4><p>共享段允许多个进程共享内存（如库代码）。</p>
<h4 id="详细说明-18"><a href="#详细说明-18" class="headerlink" title="详细说明"></a><strong>详细说明</strong></h4><ul>
<li><strong>机制</strong>：共享段在物理内存中只有一份，多个进程的段表指向同一地址。例如，<code>libc</code> 代码共享于所有进程。</li>
<li><strong>优势</strong>：节省内存，提高效率。</li>
<li><strong>实际 application</strong>：Linux 使用动态链接库（如 <code>libc.so</code>）实现共享。</li>
</ul>
<p><img src="/../image/image-20250506191739384.png" alt="image-20250506191739384"></p>
<h3 id="16-5-细粒度与粗粒度的分段"><a href="#16-5-细粒度与粗粒度的分段" class="headerlink" title="16.5 细粒度与粗粒度的分段"></a><strong>16.5 细粒度与粗粒度的分段</strong></h3><h4 id="描述-18"><a href="#描述-18" class="headerlink" title="描述"></a><strong>描述</strong></h4><ul>
<li><strong>细粒度</strong>：更多小段，灵活但复杂。</li>
<li><strong>粗粒度</strong>：较少大段，简单但灵活性低。</li>
</ul>
<h4 id="详细说明-19"><a href="#详细说明-19" class="headerlink" title="详细说明"></a><strong>详细说明</strong></h4><ul>
<li><strong>细粒度</strong>：适合动态需求，但段表开销大。例如，每个函数一个段。</li>
<li><strong>粗粒度</strong>：管理简单，但可能导致内部碎片。例如，单一数据段未完全使用。</li>
<li><strong>实际 application</strong>：现代系统倾向粗粒度（如代码、数据、栈三段）。</li>
</ul>
<h3 id="16-6-操作系统支持"><a href="#16-6-操作系统支持" class="headerlink" title="16.6 操作系统支持"></a><strong>16.6 操作系统支持</strong></h3><h4 id="描述-19"><a href="#描述-19" class="headerlink" title="描述"></a><strong>描述</strong></h4><ul>
<li><strong>段表</strong>：记录段的基址和界限。</li>
<li><strong>上下文切换</strong>：保存和恢复段寄存器。</li>
</ul>
<h4 id="详细说明-20"><a href="#详细说明-20" class="headerlink" title="详细说明"></a><strong>详细说明</strong></h4><ul>
<li><strong>段表</strong>：存储在进程控制块（PCB）中。例如，段 0 基址 <code>0x1000</code>，界限 <code>0x2000</code>。</li>
<li><strong>上下文切换</strong>：切换进程时更新段寄存器。例如，进程 A 到 B 更新 CS、DS。</li>
<li><strong>实际 application</strong>：x86 的 GDT（全局描述符表）存储段信息。</li>
</ul>
<h3 id="16-7-小结"><a href="#16-7-小结" class="headerlink" title="16.7 小结"></a><strong>16.7 小结</strong></h3><p>分段提供灵活的内存管理，但外部碎片问题促使现代系统转向分页。例如，Linux 仅在特定场景（如内核态）使用分段。</p>
<p><strong>思考问题</strong>：</p>
<ul>
<li>分段与分页相比有何优劣？</li>
<li>如何优化分段的碎片问题？</li>
</ul>
<p><strong>参考资料</strong>：</p>
<ul>
<li>x86 架构手册（段机制）。</li>
<li>《Modern Operating Systems》 by Tanenbaum。</li>
</ul>
<hr>
<h2 id="第-17-章-空闲空间管理"><a href="#第-17-章-空闲空间管理" class="headerlink" title="第 17 章 空闲空间管理"></a><strong>第 17 章 空闲空间管理</strong></h2><h3 id="17-1-假设"><a href="#17-1-假设" class="headerlink" title="17.1 假设"></a><strong>17.1 假设</strong></h3><h4 id="描述-20"><a href="#描述-20" class="headerlink" title="描述"></a><strong>描述</strong></h4><ul>
<li><strong>空闲列表</strong>：记录未分配内存。</li>
<li><strong>分配策略</strong>：决定选择哪个内存块。</li>
</ul>
<h4 id="详细说明-21"><a href="#详细说明-21" class="headerlink" title="详细说明"></a><strong>详细说明</strong></h4><ul>
<li><strong>空闲列表</strong>：可用链表（记录块地址和大小）、位图（标记空闲状态）或树实现。</li>
<li><strong>策略</strong>：影响碎片和分配速度。例如，最佳适应减少碎片，但搜索慢。</li>
<li><strong>实际 application</strong>：Linux 内核使用位图和链表管理空闲页面。</li>
</ul>
<h3 id="17-2-底层机制"><a href="#17-2-底层机制" class="headerlink" title="17.2 底层机制"></a><strong>17.2 底层机制</strong></h3><h4 id="描述-21"><a href="#描述-21" class="headerlink" title="描述"></a><strong>描述</strong></h4><ul>
<li><strong>分裂</strong>：分割大块内存。</li>
<li><strong>合并</strong>：合并相邻空闲块。</li>
</ul>
<h4 id="详细说明-22"><a href="#详细说明-22" class="headerlink" title="详细说明"></a><strong>详细说明</strong></h4><ul>
<li><strong>分裂</strong>：请求 10KB，空闲块 20KB，分割为 10KB（分配）和 10KB（空闲）。</li>
<li><strong>合并</strong>：释放一块内存，检查左右相邻块。例如，合并 <code>0x1000-0x2000</code> 和 <code>0x2000-0x3000</code> 为 <code>0x1000-0x3000</code>.</li>
<li><strong>挑战</strong>：频繁分裂合并增加管理开销。</li>
<li><strong>实际 application</strong>：Linux 的页面分配器自动合并空闲页面。</li>
</ul>
<h3 id="17-3-基本策略"><a href="#17-3-基本策略" class="headerlink" title="17.3 基本策略"></a><strong>17.3 基本策略</strong></h3><h4 id="描述-22"><a href="#描述-22" class="headerlink" title="描述"></a><strong>描述</strong></h4><ul>
<li><strong>最佳适应</strong>：选择最小足够块。</li>
<li><strong>最差适应</strong>：选择最大块。</li>
<li><strong>首次适应</strong>：选择第一个足够块。</li>
<li><strong>下次适应</strong>：从上次结束处搜索。</li>
</ul>
<h4 id="详细说明-23"><a href="#详细说明-23" class="headerlink" title="详细说明"></a><strong>详细说明</strong></h4><ul>
<li><strong>最佳适应</strong>：减少碎片，需遍历列表。例如，请求 5KB，选择 6KB 而非 10KB。</li>
<li><strong>最差适应</strong>：快速分配大块，但易产生小碎片。例如，10KB 请求从 100KB 分配。</li>
<li><strong>首次适应</strong>：简单，但前部易碎片化。例如，从头找到第一个 10KB 块。</li>
<li><strong>下次适应</strong>：减少搜索时间，但可能错过最佳块。</li>
<li><strong>实际 application</strong>：Linux 内存分配器倾向首次适应，简单高效。</li>
</ul>
<h3 id="17-4-其他方式"><a href="#17-4-其他方式" class="headerlink" title="17.4 其他方式"></a><strong>17.4 其他方式</strong></h3><h4 id="描述-23"><a href="#描述-23" class="headerlink" title="描述"></a><strong>描述</strong></h4><ul>
<li><strong>伙伴系统</strong>：按 2 的幂分割内存。</li>
<li><strong>slab 分配器</strong>：优化特定对象分配。</li>
</ul>
<h4 id="详细说明-24"><a href="#详细说明-24" class="headerlink" title="详细说明"></a><strong>详细说明</strong></h4><ul>
<li><strong>伙伴系统</strong>：内存分为 2^n 大小块，分配时找最近匹配。例如，8KB 请求分配 16KB 块，剩余 8KB 为伙伴。<ul>
<li><strong>优势</strong>：快速合并，减少碎片。</li>
<li><strong>实际 application</strong>：Linux 内核使用伙伴系统分配页面。</li>
<li><img src="/../image/image-20250506193127831.png" alt="image-20250506193127831"></li>
</ul>
</li>
<li><strong>slab 分配器</strong>：为内核对象（如进程描述符）预分配内存。例如，预分配 128 字节块，快速分配和释放。<ul>
<li><strong>实际 application</strong>：Linux 的 slab 层优化小对象分配。</li>
</ul>
</li>
<li><strong>挑战</strong>：伙伴系统不适合非 2^n 大小请求，slab 需预分配空间。</li>
</ul>
<h3 id="17-5-小结"><a href="#17-5-小结" class="headerlink" title="17.5 小结"></a><strong>17.5 小结</strong></h3><p>空闲空间管理影响内存分配效率和碎片。现代系统结合伙伴系统和 slab 分配器，优化不同场景。例如，Linux 内核平衡通用性和性能。</p>
<p><strong>思考问题</strong>：</p>
<ul>
<li>如何权衡分配速度和碎片？</li>
<li>伙伴系统如何适应动态负载？</li>
</ul>
<p><strong>参考资料</strong>：</p>
<ul>
<li>Linux 内核源代码（mm&#x2F; 目录）。</li>
<li>《Understanding the Linux Kernel》 by Bovet &amp; Cesati。</li>
</ul>
<hr>
<h2 id="第-18-章-分页：介绍"><a href="#第-18-章-分页：介绍" class="headerlink" title="第 18 章 分页：介绍"></a><strong>第 18 章 分页：介绍</strong></h2><h3 id="18-1-一个简单例子"><a href="#18-1-一个简单例子" class="headerlink" title="18.1 一个简单例子"></a><strong>18.1 一个简单例子</strong></h3><h4 id="描述-24"><a href="#描述-24" class="headerlink" title="描述"></a><strong>描述</strong></h4><p>分页将地址空间分为固定大小页面，页表记录虚拟页到物理页的映射。</p>
<h4 id="详细说明-25"><a href="#详细说明-25" class="headerlink" title="详细说明"></a><strong>详细说明</strong></h4><ul>
<li><strong>机制</strong>：页面大小通常 4KB，虚拟地址分为页号和偏移。例如，<code>0x1234</code> 的页号为 <code>0x1</code>，偏移为 <code>0x234</code>.</li>
<li><strong>页表</strong>：存储映射关系。例如，虚拟页 1 映射到物理页 5（地址 <code>0x5000</code>）。</li>
<li><strong>优势</strong>：<ul>
<li>消除外部碎片：页面可任意分配。</li>
<li>简化分配：固定大小页面。</li>
</ul>
</li>
<li><strong>局限</strong>：页表查询开销和内部碎片（页面未完全使用）。</li>
<li><strong>实际 application</strong>：Linux 和 Windows 使用 4KB 页面分页。</li>
</ul>
<p><img src="/../image/image-20250506193252871.png" alt="image-20250506193252871"></p>
<p><img src="/../image/image-20250506193446474.png" alt="image-20250506193446474"></p>
<h3 id="18-2-页表存在哪里"><a href="#18-2-页表存在哪里" class="headerlink" title="18.2 页表存在哪里"></a><strong>18.2 页表存在哪里</strong></h3><h4 id="描述-25"><a href="#描述-25" class="headerlink" title="描述"></a><strong>描述</strong></h4><p>页表存储在内存中，由页表寄存器指向。</p>
<h4 id="详细说明-26"><a href="#详细说明-26" class="headerlink" title="详细说明"></a><strong>详细说明</strong></h4><ul>
<li><strong>管理</strong>：每个进程有独立页表，上下文切换时更新页表寄存器（例如 x86 的 CR3）。</li>
<li><strong>开销</strong>：页表占用内存。例如，32 位系统、4KB 页面需 4MB 页表（2^20 页 × 4 字节&#x2F;项）。</li>
<li><strong>实际 application</strong>：Linux 内核为每个进程分配页表，存储在内核空间。</li>
</ul>
<p><img src="/../image/image-20250506193624929.png" alt="image-20250506193624929"></p>
<h3 id="18-3-列表中究竟有什么"><a href="#18-3-列表中究竟有什么" class="headerlink" title="18.3 列表中究竟有什么"></a><strong>18.3 列表中究竟有什么</strong></h3><h4 id="描述-26"><a href="#描述-26" class="headerlink" title="描述"></a><strong>描述</strong></h4><p>页表项（PTE）包括物理页框号和权限位。</p>
<h4 id="详细说明-27"><a href="#详细说明-27" class="headerlink" title="详细说明"></a><strong>详细说明</strong></h4><ul>
<li><strong>内容</strong>：<ul>
<li>物理页框号(PFN)：目标物理页面地址。</li>
<li>权限位(R&#x2F;W)：读、写、执行。</li>
<li>状态位：存在位(P)（页面是否在内存）、脏位(D)（是否修改）、访问位(A)（是否访问）。</li>
<li>用户&#x2F;超级用户位(U&#x2F;S)：定用户模式进程是否可以访问该页面。</li>
</ul>
</li>
<li><strong>示例</strong>：PTE 表示虚拟页 1 映射到物理页 10，权限为读写，存在位为 1。</li>
<li><strong>实际 application</strong>：x86 PTE 包含 20 位页框号和多位标志。</li>
</ul>
<p><img src="/../image/image-20250506193713031.png" alt="image-20250506193713031"></p>
<h3 id="18-4-分页：也很慢"><a href="#18-4-分页：也很慢" class="headerlink" title="18.4 分页：也很慢"></a><strong>18.4 分页：也很慢</strong></h3><h4 id="描述-27"><a href="#描述-27" class="headerlink" title="描述"></a><strong>描述</strong></h4><p>每次内存访问需查页表，增加延迟，TLB 缓存解决此问题。</p>
<h4 id="详细说明-28"><a href="#详细说明-28" class="headerlink" title="详细说明"></a><strong>详细说明</strong></h4><ul>
<li><strong>问题</strong>：查页表需一次内存访问，延迟翻倍。例如，内存访问从 10ns 增至 20ns。</li>
<li><strong>TLB</strong>：缓存最近 PTE，命中时转换时间接近 1ns。</li>
<li><strong>挑战</strong>：TLB 容量有限，未命中仍需查页表。</li>
<li><strong>实际 application</strong>：现代 CPU 的 TLB 容量为 64-512 条目。</li>
</ul>
<h3 id="18-5-内存追踪"><a href="#18-5-内存追踪" class="headerlink" title="18.5 内存追踪"></a><strong>18.5 内存追踪</strong></h3><h4 id="描述-28"><a href="#描述-28" class="headerlink" title="描述"></a><strong>描述</strong></h4><p>操作系统记录页面使用情况，支持替换策略。</p>
<ul>
<li>追踪该程序</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> array[<span class="number">1000</span>];</span><br><span class="line">...</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++)</span><br><span class="line">array[i] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">0x1024</span> movl $<span class="number">0x0</span>,(%edi,%eax,<span class="number">4</span>)</span><br><span class="line"><span class="number">0x1028</span> incl %eax</span><br><span class="line"><span class="number">0x102c</span> cmpl $<span class="number">0x03e8</span>,%eax</span><br><span class="line"><span class="number">0x1030</span> jne <span class="number">0x1024</span></span><br></pre></td></tr></table></figure>

<p><img src="/../image/image-20250506194647126.png" alt="image-20250506194647126"></p>
<h4 id="详细说明-29"><a href="#详细说明-29" class="headerlink" title="详细说明"></a><strong>详细说明</strong></h4><ul>
<li><strong>机制</strong>：PTE 的访问位和脏位记录页面状态。例如，访问位为 1 表示最近使用。</li>
<li><strong>用途</strong>：支持 LRU（最近最少使用）算法，选择替换页面。</li>
<li><strong>实际 application</strong>：Linux 使用页面引用计数优化替换。</li>
</ul>
<h3 id="18-6-小结"><a href="#18-6-小结" class="headerlink" title="18.6 小结"></a><strong>18.6 小结</strong></h3><p>分页消除外部碎片，但页表查询开销需优化。TLB 和多级页表是现代系统的关键。例如，Linux 的分页系统支持高效内存管理。</p>
<p><strong>思考问题</strong>：</p>
<ul>
<li>分页如何影响内存分配效率？</li>
<li>页面大小如何影响性能？</li>
</ul>
<p><strong>参考资料</strong>：</p>
<ul>
<li>Intel x86 分页文档。</li>
<li>Linux 内核分页实现。</li>
</ul>
<hr>
<h2 id="第-19-章-分页：快速地址转换-TLB"><a href="#第-19-章-分页：快速地址转换-TLB" class="headerlink" title="第 19 章 分页：快速地址转换 (TLB)"></a><strong>第 19 章 分页：快速地址转换 (TLB)</strong></h2><h3 id="19-1-TLB-的基本算法"><a href="#19-1-TLB-的基本算法" class="headerlink" title="19.1 TLB 的基本算法"></a><strong>19.1 TLB 的基本算法</strong></h3><h4 id="描述-29"><a href="#描述-29" class="headerlink" title="描述"></a><strong>描述</strong></h4><p>TLB（Translation Lookaside Buffer）缓存最近使用的页表项，命中时直接转换，未命中时查页表。</p>
<h4 id="详细说明-30"><a href="#详细说明-30" class="headerlink" title="详细说明"></a><strong>详细说明</strong></h4><ul>
<li><strong>流程</strong>：<ol>
<li>解析虚拟地址（页号 + 偏移）。</li>
<li>查 TLB：<ul>
<li>命中：获取物理页框号，计算物理地址。</li>
<li>未命中：查页表，更新 TLB。</li>
</ul>
</li>
</ol>
</li>
<li><strong>结构</strong>：TLB 为全关联或组关联缓存。例如，64 条目 TLB 缓存 64 个 PTE。</li>
<li><strong>性能</strong>：TLB 命中率高达 99%，显著降低延迟。</li>
<li><strong>实际 application</strong>：x86 CPU 的 L1 TLB 通常有 64 条目。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">VPN = (VirtualAddress &amp; VPN_MASK) &gt;&gt; <span class="built_in">SHIFT</span></span><br><span class="line">(Success, TlbEntry) = <span class="built_in">TLB_Lookup</span>(VPN)</span><br><span class="line"><span class="keyword">if</span> (Success == True) <span class="comment">// TLB Hit</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">CanAccess</span>(TlbEntry.ProtectBits) == True)</span><br><span class="line">		Offset = VirtualAddress &amp; OFFSET_MASK</span><br><span class="line">		PhysAddr = (TlbEntry.PFN &lt;&lt; SHIFT) | Offset</span><br><span class="line">		<span class="built_in">AccessMemory</span>(PhysAddr)</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="built_in">RaiseException</span>(PROTECTION_FAULT)</span><br><span class="line"><span class="keyword">else</span> <span class="comment">// TLB Miss</span></span><br><span class="line">	PTEAddr = PTBR + (VPN * <span class="built_in">sizeof</span>(PTE))</span><br><span class="line">	PTE = <span class="built_in">AccessMemory</span>(PTEAddr)</span><br><span class="line">    <span class="keyword">if</span> (PTE.Valid == False)</span><br><span class="line">		<span class="built_in">RaiseException</span>(SEGMENTATION_FAULT)</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">CanAccess</span>(PTE.ProtectBits) == False)</span><br><span class="line">		<span class="built_in">RaiseException</span>(PROTECTION_FAULT)</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="built_in">TLB_Insert</span>(VPN, PTE.PFN, PTE.ProtectBits)</span><br><span class="line">		<span class="built_in">RetryInstruction</span>()</span><br></pre></td></tr></table></figure>



<h3 id="19-2-示例：访问数组"><a href="#19-2-示例：访问数组" class="headerlink" title="19.2 示例：访问数组"></a><strong>19.2 示例：访问数组</strong></h3><h4 id="描述-30"><a href="#描述-30" class="headerlink" title="描述"></a><strong>描述</strong></h4><p>数组访问因空间局部性，TLB 命中率高。</p>
<p><img src="/../image/image-20250507184554577.png" alt="image-20250507184554577"></p>
<h4 id="详细说明-31"><a href="#详细说明-31" class="headerlink" title="详细说明"></a><strong>详细说明</strong></h4><ul>
<li><strong>局部性</strong>：连续访问 <code>arr[0]</code> 到 <code>arr[10]</code> 可能在同一 4KB 页面，TLB 一次填充即可。</li>
<li><strong>示例</strong>：4KB 页面容纳 1024 个 int，顺序访问只需 1 次 TLB 填充。</li>
<li><strong>挑战</strong>：随机访问可能导致频繁未命中。</li>
<li><strong>实际 application</strong>：数据库查询优化数组访问以提高 TLB 命中率。</li>
</ul>
<h3 id="19-3-谁来处理-TLB-未命中"><a href="#19-3-谁来处理-TLB-未命中" class="headerlink" title="19.3 谁来处理 TLB 未命中"></a><strong>19.3 谁来处理 TLB 未命中</strong></h3><h4 id="描述-31"><a href="#描述-31" class="headerlink" title="描述"></a><strong>描述</strong></h4><ul>
<li><strong>硬件处理</strong>：简单系统由 MMU 完成。</li>
<li><strong>软件处理</strong>：操作系统介入。</li>
</ul>
<h4 id="详细说明-32"><a href="#详细说明-32" class="headerlink" title="详细说明"></a><strong>详细说明</strong></h4><ul>
<li><strong>硬件</strong>：MMU 直接查页表，适用于单级页表。例如，早期 RISC 系统。</li>
<li><strong>软件</strong>：操作系统处理复杂情况，如多级页表或页面不在内存。触发异常，内核更新 TLB。</li>
<li><strong>实际 application</strong>：x86 使用硬件处理，ARM 支持软件处理。</li>
</ul>
<h3 id="19-4-TLB-的内容"><a href="#19-4-TLB-的内容" class="headerlink" title="19.4 TLB 的内容"></a><strong>19.4 TLB 的内容</strong></h3><h4 id="描述-32"><a href="#描述-32" class="headerlink" title="描述"></a><strong>描述</strong></h4><p>TLB 项包括虚拟页号、物理页框号、权限位等。</p>
<p><img src="/../image/image-20250507185339368.png" alt="image-20250507185339368"></p>
<h4 id="详细说明-33"><a href="#详细说明-33" class="headerlink" title="详细说明"></a><strong>详细说明</strong></h4><ul>
<li><strong>内容</strong>：<ul>
<li>虚拟页号：匹配虚拟地址。</li>
<li>物理页框号：目标地址。</li>
<li>权限：读、写、执行。</li>
<li>ASID（地址空间标识符）：区分进程。</li>
</ul>
</li>
<li><strong>示例</strong>：TLB 项表示虚拟页 1（ASID&#x3D;1）映射到物理页 10，读写权限。</li>
<li><strong>实际 application</strong>：ARM TLB 包含 ASID 字段，支持多进程缓存。</li>
</ul>
<h3 id="19-5-上下文切换时对-TLB-的处理"><a href="#19-5-上下文切换时对-TLB-的处理" class="headerlink" title="19.5 上下文切换时对 TLB 的处理"></a><strong>19.5 上下文切换时对 TLB 的处理</strong></h3><h4 id="描述-33"><a href="#描述-33" class="headerlink" title="描述"></a><strong>描述</strong></h4><ul>
<li><strong>问题</strong>：进程切换可能导致 TLB 冲突。（不同进程相同VPN映射到不同的PFN）</li>
<li><strong>解决方案</strong>：<ul>
<li>刷新 TLB。</li>
<li>使用 ASID。</li>
</ul>
</li>
</ul>
<p><img src="/../image/image-20250507185510274.png" alt="image-20250507185510274"></p>
<h4 id="详细说明-34"><a href="#详细说明-34" class="headerlink" title="详细说明"></a><strong>详细说明</strong></h4><ul>
<li><strong>刷新 TLB</strong>：清空所有条目，开销大。例如，切换进程后重新填充 TLB。</li>
<li><strong>ASID</strong>：标记进程 ID，保留 TLB 项。例如，ASID&#x3D;1 的条目属于进程 A。</li>
<li><strong>实际 application</strong>：x86 使用 PCID（类似 ASID），Linux 优化上下文切换。</li>
</ul>
<p><img src="/../image/image-20250507185712809.png" alt="image-20250507185712809"></p>
<h3 id="19-6-TLB-替换策略"><a href="#19-6-TLB-替换策略" class="headerlink" title="19.6 TLB 替换策略"></a><strong>19.6 TLB 替换策略</strong></h3><h4 id="描述-34"><a href="#描述-34" class="headerlink" title="描述"></a><strong>描述</strong></h4><ul>
<li><strong>LRU</strong>：替换最近最少使用项。</li>
<li><strong>随机</strong>：随机替换。</li>
</ul>
<h4 id="详细说明-35"><a href="#详细说明-35" class="headerlink" title="详细说明"></a><strong>详细说明</strong></h4><ul>
<li><strong>LRU(least-recently-used)</strong>：记录访问顺序，命中率高，但硬件开销大。</li>
<li><strong>随机</strong>：简单，适用于小 TLB，效果较差。</li>
<li><strong>实际 application</strong>：现代 CPU 常使用近似 LRU（如伪 LRU）。</li>
</ul>
<h3 id="19-7-实际系统的-TLB-表项"><a href="#19-7-实际系统的-TLB-表项" class="headerlink" title="19.7 实际系统的 TLB 表项"></a><strong>19.7 实际系统的 TLB 表项</strong></h3><h4 id="描述-35"><a href="#描述-35" class="headerlink" title="描述"></a><strong>描述</strong></h4><p>支持大页、多级缓存等优化。</p>
<p><img src="/../image/image-20250507185858538.png" alt="image-20250507185858538"></p>
<h4 id="详细说明-36"><a href="#详细说明-36" class="headerlink" title="详细说明"></a><strong>详细说明</strong></h4><ul>
<li><strong>大页</strong>：2MB 或 1GB 页面减少 TLB 条目需求。</li>
<li><strong>多级 TLB</strong>：L1 TLB 快速（10-20 周期），L2 TLB 容量大（100 周期）。</li>
<li><strong>实际 application</strong>：Intel Skylake CPU 有 64 条目 L1 TLB 和 1536 条目 L2 TLB。</li>
</ul>
<h3 id="19-8-小结"><a href="#19-8-小结" class="headerlink" title="19.8 小结"></a><strong>19.8 小结</strong></h3><p>TLB 显著提升地址转换速度，是分页系统的核心。高命中率使内存访问延迟接近物理内存。例如，现代 CPU 的 TLB 优化支持高性能计算。</p>
<p><strong>思考问题</strong>：</p>
<ul>
<li>TLB 命中率如何影响程序性能？</li>
<li>大页如何优化 TLB 使用？</li>
</ul>
<p><strong>参考资料</strong>：</p>
<ul>
<li>Intel 优化手册（TLB 部分）。</li>
<li>ARM 架构参考手册。</li>
</ul>
<hr>
<h2 id="第-20-章-分页：较小的表"><a href="#第-20-章-分页：较小的表" class="headerlink" title="第 20 章 分页：较小的表"></a><strong>第 20 章 分页：较小的表</strong></h2><h3 id="20-1-简单的解决方案：更大的页"><a href="#20-1-简单的解决方案：更大的页" class="headerlink" title="20.1 简单的解决方案：更大的页"></a><strong>20.1 简单的解决方案：更大的页</strong></h3><h4 id="描述-36"><a href="#描述-36" class="headerlink" title="描述"></a><strong>描述</strong></h4><p>大页减少页表项，但增加内部碎片。</p>
<h4 id="详细说明-37"><a href="#详细说明-37" class="headerlink" title="详细说明"></a><strong>详细说明</strong></h4><ul>
<li><strong>机制</strong>：2MB 或 1GB 页面。例如，32 位系统 2MB 页面只需 2K 页表项（vs 4MB for 4KB 页面）。</li>
<li><strong>优势</strong>：减少页表大小，降低 TLB 压力。</li>
<li><strong>问题</strong>：内部碎片。例如，分配 2MB 页面仅用 1KB，浪费内存。</li>
<li><strong>实际 application</strong>：Linux 支持 HugeTLB，数据库使用大页优化性能。</li>
</ul>
<h3 id="20-2-多级页表"><a href="#20-2-多级页表" class="headerlink" title="20.2 多级页表"></a><strong>20.2 多级页表</strong></h3><h4 id="描述-37"><a href="#描述-37" class="headerlink" title="描述"></a><strong>描述</strong></h4><p>将页表分级，仅加载需要的部分。</p>
<p><img src="/../image/image-20250507190216179.png" alt="image-20250507190216179"></p>
<h4 id="详细说明-38"><a href="#详细说明-38" class="headerlink" title="详细说明"></a><strong>详细说明</strong></h4><ul>
<li><strong>结构</strong>：两级页表含页目录和页表。例如，页目录指向多个页表，页表含 PTE。</li>
<li><strong>优势</strong>：未使用地址空间无需分配页表，节省内存。例如，稀疏地址空间只需少量页表。</li>
<li><strong>示例</strong>：x86 两级页表，32 位系统页目录含 1024 项，每项指向 4KB 页表。</li>
<li><strong>挑战</strong>：增加查询延迟（多次内存访问）。</li>
<li><strong>实际 application</strong>：Linux 和 Windows 使用 4 级页表（64 位系统）。</li>
</ul>
<p><img src="/../image/image-20250507190643280.png" alt="image-20250507190643280"></p>
<h3 id="20-3-反向页表"><a href="#20-3-反向页表" class="headerlink" title="20.3 反向页表"></a><strong>20.3 反向页表</strong></h3><h4 id="描述-38"><a href="#描述-38" class="headerlink" title="描述"></a><strong>描述</strong></h4><p>以物理页为索引，记录虚拟页。</p>
<h4 id="详细说明-39"><a href="#详细说明-39" class="headerlink" title="详细说明"></a><strong>详细说明</strong></h4><ul>
<li><strong>机制</strong>：页表大小与物理内存成正比。例如，1GB 内存、4KB 页面需 256K 项。</li>
<li><strong>优势</strong>：适合大地址空间，节省内存。</li>
<li><strong>问题</strong>：查找效率低，需搜索整个表（可用哈希表优化）。</li>
<li><strong>实际 application</strong>：PowerPC 和 SPARC 架构使用反向页表。</li>
</ul>
<h3 id="20-4-将页表交换到磁盘"><a href="#20-4-将页表交换到磁盘" class="headerlink" title="20.4 将页表交换到磁盘"></a><strong>20.4 将页表交换到磁盘</strong></h3><h4 id="描述-39"><a href="#描述-39" class="headerlink" title="描述"></a><strong>描述</strong></h4><p>不活跃页表项移到磁盘。</p>
<h4 id="详细说明-40"><a href="#详细说明-40" class="headerlink" title="详细说明"></a><strong>详细说明</strong></h4><ul>
<li><strong>机制</strong>：内存压力大时交换页表。例如，进程休眠时其页表移出。</li>
<li><strong>问题</strong>：访问时需从磁盘加载，延迟高（毫秒级）。</li>
<li><strong>实际 application</strong>：Linux 支持页表交换，但谨慎使用以避免性能下降。</li>
</ul>
<h3 id="20-5-混合方法：分页和分段"><a href="#20-5-混合方法：分页和分段" class="headerlink" title="20.5 混合方法：分页和分段"></a><strong>20.5 混合方法：分页和分段</strong></h3><h4 id="描述-40"><a href="#描述-40" class="headerlink" title="描述"></a><strong>描述</strong></h4><p>结合分段灵活性和分页效率。</p>
<h4 id="详细说明-41"><a href="#详细说明-41" class="headerlink" title="详细说明"></a><strong>详细说明</strong></h4><ul>
<li><strong>机制</strong>：虚拟地址先分段生成线性地址，再分页。例如，x86 段基址加偏移生成线性地址，分页映射到物理地址。</li>
<li><strong>优势</strong>：逻辑划分清晰，碎片少。</li>
<li><strong>问题</strong>：增加复杂性，需管理段表和页表。</li>
<li><strong>实际 application</strong>：x86 保护模式使用段页式管理。</li>
</ul>
<p><img src="/../image/image-20250507190940552.png" alt="image-20250507190940552"></p>
<h3 id="20-6-小结"><a href="#20-6-小结" class="headerlink" title="20.6 小结"></a><strong>20.6 小结</strong></h3><p>优化页表大小提升性能。多级页表和大页平衡内存和效率。例如，Linux 的 4 级页表支持 64 位地址空间的高效管理。</p>
<p><strong>思考问题</strong>：</p>
<ul>
<li>多级页表如何影响查询性能？</li>
<li>大页适合哪些应用场景？</li>
</ul>
<p><strong>参考资料</strong>：</p>
<ul>
<li>x86 64 位分页文档。</li>
<li>Linux HugeTLB 实现。</li>
</ul>
<hr>
<h2 id="第-21-章-超越物理内存：机制"><a href="#第-21-章-超越物理内存：机制" class="headerlink" title="第 21 章 超越物理内存：机制"></a><strong>第 21 章 超越物理内存：机制</strong></h2><h3 id="21-1-超越物理内存"><a href="#21-1-超越物理内存" class="headerlink" title="21.1 超越物理内存"></a><strong>21.1 超越物理内存</strong></h3><h4 id="描述-41"><a href="#描述-41" class="headerlink" title="描述"></a><strong>描述</strong></h4><p>虚拟内存支持超出物理内存的地址空间，通过交换实现。</p>
<h4 id="详细说明-42"><a href="#详细说明-42" class="headerlink" title="详细说明"></a><strong>详细说明</strong></h4><ul>
<li><strong>机制</strong>：不活跃页面移到磁盘。例如，1GB 物理内存运行 2GB 程序。</li>
<li><strong>优势</strong>：支持大型程序和多任务。</li>
<li><strong>问题</strong>：磁盘 I&#x2F;O 延迟高（毫秒级 vs 内存的纳秒级）。</li>
<li><strong>实际 application</strong>：Linux 使用交换分区支持内存扩展。</li>
</ul>
<h3 id="21-2-交换空间"><a href="#21-2-交换空间" class="headerlink" title="21.2 交换空间"></a><strong>21.2 交换空间</strong></h3><h4 id="描述-42"><a href="#描述-42" class="headerlink" title="描述"></a><strong>描述</strong></h4><p>磁盘上存储交换页的区域。</p>
<p><img src="/../image/image-20250507191059274.png" alt="image-20250507191059274"></p>
<h4 id="详细说明-43"><a href="#详细说明-43" class="headerlink" title="详细说明"></a><strong>详细说明</strong></h4><ul>
<li><strong>管理</strong>：可为分区或文件。例如，Linux 用 <code>swap</code> 分区。</li>
<li><strong>大小</strong>：通常设为物理内存的 1-2 倍。例如，4GB 内存配 4-8GB 交换空间。</li>
<li><strong>挑战</strong>：过度依赖交换降低性能。</li>
<li><strong>实际 application</strong>：Linux 的 <code>swapon</code> 命令启用交换分区。</li>
</ul>
<h3 id="21-3-存在位"><a href="#21-3-存在位" class="headerlink" title="21.3 存在位"></a><strong>21.3 存在位</strong></h3><h4 id="描述-43"><a href="#描述-43" class="headerlink" title="描述"></a><strong>描述</strong></h4><p>指示页面是否在内存（1&#x3D;内存，0&#x3D;磁盘）。</p>
<h4 id="详细说明-44"><a href="#详细说明-44" class="headerlink" title="详细说明"></a><strong>详细说明</strong></h4><ul>
<li><strong>位置</strong>：存储在 PTE 中。</li>
<li><strong>作用</strong>：存在位为 0 触发页错误。</li>
<li><strong>示例</strong>：PTE 存在位为 0，表示页面在磁盘，需加载。</li>
<li><strong>实际 application</strong>：Linux PTE 使用存在位管理页面状态。</li>
</ul>
<h3 id="21-4-页错误"><a href="#21-4-页错误" class="headerlink" title="21.4 页错误"></a><strong>21.4 页错误</strong></h3><h4 id="描述-44"><a href="#描述-44" class="headerlink" title="描述"></a><strong>描述</strong></h4><p>访问不在内存的页面时触发。</p>
<h4 id="详细说明-45"><a href="#详细说明-45" class="headerlink" title="详细说明"></a><strong>详细说明</strong></h4><ul>
<li><strong>类型</strong>：<ul>
<li><strong>硬错误</strong>：页面在磁盘，需加载。</li>
<li><strong>软错误</strong>：页面未映射但在内存（如写时复制）。</li>
</ul>
</li>
<li><strong>触发</strong>：存在位为 0 或权限不符。</li>
<li><strong>实际 application</strong>：Linux 的页错误处理优化内存分配。</li>
</ul>
<h3 id="21-5-页错误处理流程"><a href="#21-5-页错误处理流程" class="headerlink" title="21.5 页错误处理流程"></a><strong>21.5 页错误处理流程</strong></h3><h4 id="描述-45"><a href="#描述-45" class="headerlink" title="描述"></a><strong>描述</strong></h4><ol>
<li>硬件检测页错误，陷入内核。</li>
<li>定位页面（磁盘）。</li>
<li>选择物理页框（可能替换页面）。</li>
<li>从磁盘读取页面。</li>
<li>更新页表，设置存在位。</li>
<li>返回用户空间，重试指令。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">VPN = (VirtualAddress &amp; VPN_MASK) &gt;&gt; <span class="built_in">SHIFT</span></span><br><span class="line">(Success, TlbEntry) = <span class="built_in">TLB_Lookup</span>(VPN)</span><br><span class="line"><span class="keyword">if</span> (Success == True) <span class="comment">// TLB Hit</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">CanAccess</span>(TlbEntry.ProtectBits) == True)</span><br><span class="line">		Offset = VirtualAddress &amp; OFFSET_MASK</span><br><span class="line">		PhysAddr = (TlbEntry.PFN &lt;&lt; SHIFT) | Offset</span><br><span class="line">		Register = <span class="built_in">AccessMemory</span>(PhysAddr)</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	<span class="built_in">RaiseException</span>(PROTECTION_FAULT)</span><br><span class="line"><span class="keyword">else</span> <span class="comment">// TLB Miss</span></span><br><span class="line">	PTEAddr = PTBR + (VPN * <span class="built_in">sizeof</span>(PTE))</span><br><span class="line">	PTE = <span class="built_in">AccessMemory</span>(PTEAddr)</span><br><span class="line">	<span class="keyword">if</span> (PTE.Valid == False)</span><br><span class="line">		<span class="built_in">RaiseException</span>(SEGMENTATION_FAULT)</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">CanAccess</span>(PTE.ProtectBits) == False)</span><br><span class="line">			<span class="built_in">RaiseException</span>(PROTECTION_FAULT)</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (PTE.Present == True)</span><br><span class="line">			<span class="comment">// assuming hardware-managed TLB</span></span><br><span class="line">			<span class="built_in">TLB_Insert</span>(VPN, PTE.PFN, PTE.ProtectBits)</span><br><span class="line">			<span class="built_in">RetryInstruction</span>()</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (PTE.Present == False)</span><br><span class="line">			<span class="built_in">RaiseException</span>(PAGE_FAULT)</span><br></pre></td></tr></table></figure>



<h4 id="详细说明-46"><a href="#详细说明-46" class="headerlink" title="详细说明"></a><strong>详细说明</strong></h4><ul>
<li>**步骤 **：替换页面使用 LRU 等策略。</li>
<li><strong>瓶颈</strong>：磁盘 I&#x2F;O 耗时（例如，4KB 页面加载需数毫秒）。</li>
<li><strong>示例</strong>：访问虚拟地址 <code>0x1000</code>，存在位为 0，内核从磁盘加载页面。</li>
<li><strong>实际 application</strong>：Linux 的 <code>do_page_fault</code> 函数处理页错误。</li>
</ul>
<h3 id="21-6-内存满了怎么办"><a href="#21-6-内存满了怎么办" class="headerlink" title="21.6 内存满了怎么办"></a><strong>21.6 内存满了怎么办</strong></h3><h4 id="描述-46"><a href="#描述-46" class="headerlink" title="描述"></a><strong>描述</strong></h4><p>页面替换将页面交换到磁盘。</p>
<h4 id="详细说明-47"><a href="#详细说明-47" class="headerlink" title="详细说明"></a><strong>详细说明</strong></h4><ul>
<li><strong>策略</strong>：LRU 选择最近最少使用页面。</li>
<li><strong>示例</strong>：替换未访问的后台进程页面。</li>
<li><strong>挑战</strong>：选择不当导致频繁页错误。</li>
<li><strong>实际 application</strong>：Linux 使用 kswapd 守护进程管理页面替换。</li>
</ul>
<h3 id="21-7-交换何时真正发生"><a href="#21-7-交换何时真正发生" class="headerlink" title="21.7 交换何时真正发生"></a><strong>21.7 交换何时真正发生</strong></h3><h4 id="描述-47"><a href="#描述-47" class="headerlink" title="描述"></a><strong>描述</strong></h4><ul>
<li><strong>懒惰策略</strong>：内存不足时交换。</li>
<li><strong>预取</strong>：提前加载页面。</li>
</ul>
<h4 id="详细说明-48"><a href="#详细说明-48" class="headerlink" title="详细说明"></a><strong>详细说明</strong></h4><ul>
<li><strong>懒惰</strong>：减少不必要 I&#x2F;O。例如，仅在内存满时交换。</li>
<li><strong>预取</strong>：加载相邻页面，利用局部性。例如，顺序访问时预取下一页面。</li>
<li><strong>实际 application</strong>：Linux 的 <code>vm.swappiness</code> 参数控制交换倾向。</li>
</ul>
<h3 id="21-8-小结"><a href="#21-8-小结" class="headerlink" title="21.8 小结"></a><strong>21.8 小结</strong></h3><p>交换扩展内存，但需避免性能瓶颈。过度交换导致“抖动”（频繁页面交换）。例如，Linux 优化交换策略以平衡性能和容量。</p>
<p><strong>思考问题</strong>：</p>
<ul>
<li>交换如何影响实时系统？</li>
<li>如何优化交换空间大小？</li>
</ul>
<p><strong>参考资料</strong>：</p>
<ul>
<li>Linux 交换机制文档。</li>
<li>《Operating System Concepts》 by Silberschatz。</li>
</ul>
<hr>
<h2 id="第-22-章-超越物理内存：策略"><a href="#第-22-章-超越物理内存：策略" class="headerlink" title="第 22 章 超越物理内存：策略"></a><strong>第 22 章 超越物理内存：策略</strong></h2><h3 id="22-1-缓存管理"><a href="#22-1-缓存管理" class="headerlink" title="22.1 缓存管理"></a><strong>22.1 缓存管理</strong></h3><h4 id="描述-48"><a href="#描述-48" class="headerlink" title="描述"></a><strong>描述</strong></h4><p>虚拟内存视为物理内存的缓存，决定保留哪些页面。</p>
<h4 id="详细说明-49"><a href="#详细说明-49" class="headerlink" title="详细说明"></a><strong>详细说明</strong></h4><ul>
<li><strong>目标</strong>：最大化缓存命中率，减少页错误。</li>
<li><strong>核心</strong>：页面替换策略。</li>
<li><strong>实际 application</strong>：Linux 的页面缓存管理优化内存使用。</li>
</ul>
<h3 id="22-2-最优替换策略"><a href="#22-2-最优替换策略" class="headerlink" title="22.2 最优替换策略"></a><strong>22.2 最优替换策略</strong></h3><h4 id="描述-49"><a href="#描述-49" class="headerlink" title="描述"></a><strong>描述</strong></h4><p>替换未来最晚使用的页面。</p>
<h4 id="详细说明-50"><a href="#详细说明-50" class="headerlink" title="详细说明"></a><strong>详细说明</strong></h4><ul>
<li><strong>理论</strong>：需预测未来，仅作基准。例如，页面 A 下次访问在 10 秒后，B 在 1 秒后，替换 A。</li>
<li><strong>局限</strong>：实际无法预测。</li>
<li><strong>实际 application</strong>：用于评估其他策略效果。</li>
</ul>
<p><img src="/../image/image-20250507191907469.png" alt="image-20250507191907469"></p>
<h3 id="22-3-简单策略：FIFO"><a href="#22-3-简单策略：FIFO" class="headerlink" title="22.3 简单策略：FIFO"></a><strong>22.3 简单策略：FIFO</strong></h3><h4 id="描述-50"><a href="#描述-50" class="headerlink" title="描述"></a><strong>描述</strong></h4><p>先入先出替换。</p>
<h4 id="详细说明-51"><a href="#详细说明-51" class="headerlink" title="详细说明"></a><strong>详细说明</strong></h4><ul>
<li><strong>机制</strong>：用队列记录页面加载顺序。</li>
<li><strong>问题</strong>：忽略使用频率。例如，替换刚加载的活跃页面。</li>
<li><strong>实际 application</strong>：早期系统使用 FIFO，现代系统较少采用。</li>
</ul>
<p><img src="/../image/image-20250507191930432.png" alt="image-20250507191930432"></p>
<h3 id="22-4-另一简单策略：随机"><a href="#22-4-另一简单策略：随机" class="headerlink" title="22.4 另一简单策略：随机"></a><strong>22.4 另一简单策略：随机</strong></h3><h4 id="描述-51"><a href="#描述-51" class="headerlink" title="描述"></a><strong>描述</strong></h4><p>随机选择替换页面。</p>
<h4 id="详细说明-52"><a href="#详细说明-52" class="headerlink" title="详细说明"></a><strong>详细说明</strong></h4><ul>
<li><strong>优势</strong>：实现简单，无需跟踪历史。</li>
<li><strong>问题</strong>：效果不稳定，可能替换活跃页面。</li>
<li><strong>实际 application</strong>：低负载场景可接受。</li>
</ul>
<p><img src="/../image/image-20250507191948458.png" alt="image-20250507191948458"></p>
<h3 id="22-5-基于历史信息的算法"><a href="#22-5-基于历史信息的算法" class="headerlink" title="22.5 基于历史信息的算法"></a><strong>22.5 基于历史信息的算法</strong></h3><h4 id="描述-52"><a href="#描述-52" class="headerlink" title="描述"></a><strong>描述</strong></h4><ul>
<li><strong>LRU</strong>：替换最近最少使用页面。</li>
<li><strong>LFU(least-frequently-used)</strong>：替换使用频率最低页面。</li>
</ul>
<h4 id="详细说明-53"><a href="#详细说明-53" class="headerlink" title="详细说明"></a><strong>详细说明</strong></h4><ul>
<li><strong>LRU</strong>：利用时间局部性。例如，替换 5 分钟未用页面。</li>
<li><strong>LFU</strong>：适合稳定访问模式，但需维护频率计数。</li>
<li><strong>挑战</strong>：历史记录增加开销。</li>
<li><strong>实际 application</strong>：Linux 近似 LRU，优化替换效率。</li>
</ul>
<h3 id="22-6-利用历史数据：LRU"><a href="#22-6-利用历史数据：LRU" class="headerlink" title="22.6 利用历史数据：LRU"></a><strong>22.6 利用历史数据：LRU</strong></h3><h4 id="描述-53"><a href="#描述-53" class="headerlink" title="描述"></a><strong>描述</strong></h4><p>记录访问时间，近似如时钟算法。</p>
<h4 id="详细说明-54"><a href="#详细说明-54" class="headerlink" title="详细说明"></a><strong>详细说明</strong></h4><ul>
<li><strong>精确 LRU</strong>：维护时间戳，开销大。</li>
<li><strong>时钟算法</strong>：用引用位模拟，指针循环检查：<ul>
<li>引用位为 1：清 0，跳过。</li>
<li>引用位为 0：替换。</li>
</ul>
</li>
<li><strong>实际 application</strong>：Linux 的时钟算法（CLOCK-Pro）高效实现 LRU。</li>
</ul>
<h3 id="22-7-工作负载示例"><a href="#22-7-工作负载示例" class="headerlink" title="22.7 工作负载示例"></a><strong>22.7 工作负载示例</strong></h3><h4 id="描述-54"><a href="#描述-54" class="headerlink" title="描述"></a><strong>描述</strong></h4><p>程序访问具局部性，LRU 利用此特性。</p>
<p><img src="/../image/image-20250507192154382.png" alt="image-20250507192154382"></p>
<h4 id="详细说明-55"><a href="#详细说明-55" class="headerlink" title="详细说明"></a><strong>详细说明</strong></h4><ul>
<li><strong>时间局部性</strong>：最近访问页面易再访问。例如，循环变量。</li>
<li><strong>空间局部性</strong>：相邻页面常一起访问。例如，数组遍历。</li>
<li><strong>示例</strong>：顺序访问数组，LRU 保留活跃页面，减少页错误。</li>
<li><strong>实际 application</strong>：数据库优化访问模式以提高局部性。</li>
</ul>
<h3 id="22-8-考虑脏页"><a href="#22-8-考虑脏页" class="headerlink" title="22.8 考虑脏页"></a><strong>22.8 考虑脏页</strong></h3><h4 id="描述-55"><a href="#描述-55" class="headerlink" title="描述"></a><strong>描述</strong></h4><p>脏页（已修改）替换需写回磁盘，优先替换干净页面。</p>
<h4 id="详细说明-56"><a href="#详细说明-56" class="headerlink" title="详细说明"></a><strong>详细说明</strong></h4><ul>
<li><strong>优化</strong>：干净页面直接覆盖，减少 I&#x2F;O。</li>
<li><strong>脏位</strong>：PTE 标记修改状态。例如，脏位为 1 表示需写回。</li>
<li><strong>实际 application</strong>：Linux 优先替换干净页面，优化交换性能。</li>
</ul>
<h3 id="22-9-基于近似-LRU-的实现"><a href="#22-9-基于近似-LRU-的实现" class="headerlink" title="22.9 基于近似 LRU 的实现"></a><strong>22.9 基于近似 LRU 的实现</strong></h3><h4 id="描述-56"><a href="#描述-56" class="headerlink" title="描述"></a><strong>描述</strong></h4><p>时钟算法用引用位模拟 LRU。</p>
<h4 id="详细说明-57"><a href="#详细说明-57" class="headerlink" title="详细说明"></a><strong>详细说明</strong></h4><ul>
<li><strong>机制</strong>：访问时置引用位为 1，替换时清 0 或替换。</li>
<li><strong>优势</strong>：硬件支持简单，效率高。</li>
<li><strong>实际 application</strong>：Linux 的页面替换算法基于时钟变种。</li>
</ul>
<h3 id="22-10-其他虚拟内存策略"><a href="#22-10-其他虚拟内存策略" class="headerlink" title="22.10 其他虚拟内存策略"></a><strong>22.10 其他虚拟内存策略</strong></h3><h4 id="描述-57"><a href="#描述-57" class="headerlink" title="描述"></a><strong>描述</strong></h4><ul>
<li><strong>预取</strong>：提前加载页面。</li>
<li><strong>群集</strong>：加载多个相关页面。</li>
</ul>
<h4 id="详细说明-58"><a href="#详细说明-58" class="headerlink" title="详细说明"></a><strong>详细说明</strong></h4><ul>
<li><strong>预取</strong>：预测未来访问。例如，顺序访问时加载下一页面。</li>
<li><strong>群集</strong>：一次性加载相邻页面。例如，加载 4KB 页面组。</li>
<li><strong>实际 application</strong>：Linux 的 readahead 机制实现预取。</li>
</ul>
<h3 id="22-11-抖动"><a href="#22-11-抖动" class="headerlink" title="22.11 抖动"></a><strong>22.11 抖动</strong></h3><h4 id="描述-58"><a href="#描述-58" class="headerlink" title="描述"></a><strong>描述</strong></h4><p>内存压力下频繁交换，导致性能下降。</p>
<h4 id="详细说明-59"><a href="#详细说明-59" class="headerlink" title="详细说明"></a><strong>详细说明</strong></h4><ul>
<li><strong>原因</strong>：工作集超出物理内存。例如，运行多个大型程序。</li>
<li><strong>预防</strong>：<ul>
<li>限制进程数量。</li>
<li>增加物理内存。</li>
<li>调整调度策略。</li>
</ul>
</li>
<li><strong>实际 application</strong>：Linux 的 OOM（Out-Of-Memory）杀手终止进程以防抖动。</li>
</ul>
<h3 id="22-12-小结"><a href="#22-12-小结" class="headerlink" title="22.12 小结"></a><strong>22.12 小结</strong></h3><p>页面替换策略影响虚拟内存性能。LRU 结合预取优化大多数场景。例如，Linux 的缓存管理平衡命中率和 I&#x2F;O 开销。</p>
<p><strong>思考问题</strong>：</p>
<ul>
<li>如何检测和预防抖动？</li>
<li>LRU 与 LFU 在何种场景下更优？</li>
</ul>
<p><strong>参考资料</strong>：</p>
<ul>
<li>Linux 页面替换算法文档。</li>
<li>《Computer Architecture》 by Hennessy &amp; Patterson。</li>
</ul>
<hr>
<h2 id="第-23-章-VAX-VMS-虚拟内存系统"><a href="#第-23-章-VAX-VMS-虚拟内存系统" class="headerlink" title="第 23 章 VAX&#x2F;VMS 虚拟内存系统"></a><strong>第 23 章 VAX&#x2F;VMS 虚拟内存系统</strong></h2><h3 id="23-1-背景"><a href="#23-1-背景" class="headerlink" title="23.1 背景"></a><strong>23.1 背景</strong></h3><h4 id="描述-59"><a href="#描述-59" class="headerlink" title="描述"></a><strong>描述</strong></h4><p>VAX&#x2F;VMS 是 DEC 公司开发的操作系统，展示虚拟内存应用。</p>
<h4 id="详细说明-60"><a href="#详细说明-60" class="headerlink" title="详细说明"></a><strong>详细说明</strong></h4><ul>
<li><strong>历史</strong>：20 世纪 70-80 年代开发，运行于 VAX 架构，影响现代系统（如 Windows NT）。</li>
<li><strong>特点</strong>：支持多用户、虚拟内存和可靠性。</li>
<li><strong>实际 application</strong>：用于企业计算和科学计算。</li>
</ul>
<h3 id="23-2-内存管理硬件"><a href="#23-2-内存管理硬件" class="headerlink" title="23.2 内存管理硬件"></a><strong>23.2 内存管理硬件</strong></h3><h4 id="描述-60"><a href="#描述-60" class="headerlink" title="描述"></a><strong>描述</strong></h4><p>采用段页式管理，多级页表。</p>
<h4 id="详细说明-61"><a href="#详细说明-61" class="headerlink" title="详细说明"></a><strong>详细说明</strong></h4><ul>
<li><strong>机制</strong>：虚拟地址先分段生成线性地址，再分页。</li>
<li><strong>结构</strong>：两级页表（页目录 + 页表）。</li>
<li><strong>优势</strong>：灵活性和效率兼顾，段支持逻辑划分，页消除碎片。</li>
<li><strong>实际 application</strong>：VAX 的段页式设计影响 x86 保护模式。</li>
</ul>
<h3 id="23-3-一个真实的地址空间"><a href="#23-3-一个真实的地址空间" class="headerlink" title="23.3 一个真实的地址空间"></a><strong>23.3 一个真实的地址空间</strong></h3><h4 id="描述-61"><a href="#描述-61" class="headerlink" title="描述"></a><strong>描述</strong></h4><p>分为系统空间和用户空间（P0、P1 段）。</p>
<p><img src="/../image/image-20250507192435620.png" alt="image-20250507192435620"></p>
<h4 id="详细说明-62"><a href="#详细说明-62" class="headerlink" title="详细说明"></a><strong>详细说明</strong></h4><ul>
<li><strong>系统空间</strong>：存放内核代码、数据和共享库。</li>
<li><strong>用户空间</strong>：<ul>
<li>P0 段：代码、数据、堆（低地址向高地址增长）。</li>
<li>P1 段：栈（高地址向低地址增长）。</li>
</ul>
</li>
<li><strong>示例</strong>：P0 段基址 <code>0x0000</code>，P1 段基址 <code>0x7FFF</code>，支持动态堆栈增长。</li>
<li><strong>实际 application</strong>：VMS 地址空间布局优化多任务。</li>
</ul>
<h3 id="23-4-页替换"><a href="#23-4-页替换" class="headerlink" title="23.4 页替换"></a><strong>23.4 页替换</strong></h3><h4 id="描述-62"><a href="#描述-62" class="headerlink" title="描述"></a><strong>描述</strong></h4><p>FIFO 结合“第二次机会”，维护工作集。</p>
<h4 id="详细说明-63"><a href="#详细说明-63" class="headerlink" title="详细说明"></a><strong>详细说明</strong></h4><ul>
<li><strong>第二次机会</strong>：类似时钟算法，检查引用位：<ul>
<li>引用位为 1：清 0，跳过。</li>
<li>引用位为 0：替换。</li>
</ul>
</li>
<li><strong>工作集</strong>：进程的活跃页面集合，决定内存分配。</li>
<li><strong>实际 application</strong>：VMS 动态调整工作集大小，优化页面保留。</li>
</ul>
<h3 id="23-5-其他虚拟内存技巧"><a href="#23-5-其他虚拟内存技巧" class="headerlink" title="23.5 其他虚拟内存技巧"></a><strong>23.5 其他虚拟内存技巧</strong></h3><h4 id="描述-63"><a href="#描述-63" class="headerlink" title="描述"></a><strong>描述</strong></h4><ul>
<li><strong>预取</strong>：加载相邻页面。</li>
<li><strong>页面锁定</strong>：防止关键页面交换。</li>
</ul>
<h4 id="详细说明-64"><a href="#详细说明-64" class="headerlink" title="详细说明"></a><strong>详细说明</strong></h4><ul>
<li><strong>预取</strong>：顺序访问时加载下一页面，减少页错误。</li>
<li><strong>页面锁定</strong>：内核或关键用户页面常驻内存。例如，锁定驱动程序页面。</li>
<li><strong>实际 application</strong>：VMS 的预取机制提高 I&#x2F;O 效率。</li>
</ul>
<h3 id="23-6-小结"><a href="#23-6-小结" class="headerlink" title="23.6 小结"></a><strong>23.6 小结</strong></h3><p>VAX&#x2F;VMS 展示复杂虚拟内存实现。其段页式设计和替换策略影响了现代操作系统。例如，Windows 的内存管理借鉴了 VMS 的工作集概念。</p>
<p><strong>思考问题</strong>：</p>
<ul>
<li>VMS 的工作集如何适应动态负载？</li>
<li>段页式与纯分页相比有何优劣？</li>
</ul>
<p><strong>参考资料</strong>：</p>
<ul>
<li>VAX&#x2F;VMS 技术文档。</li>
<li>《VMS Internals and Data Structures》 by Goldenberg。</li>
</ul>
<hr>
<h2 id="第-24-章-内存虚拟化总结对话"><a href="#第-24-章-内存虚拟化总结对话" class="headerlink" title="第 24 章 内存虚拟化总结对话"></a><strong>第 24 章 内存虚拟化总结对话</strong></h2><h3 id="内容概述-1"><a href="#内容概述-1" class="headerlink" title="内容概述"></a><strong>内容概述</strong></h3><p>通过对话回顾内存虚拟化的关键概念：地址空间、分页、分段、TLB、页面替换等，强调其对现代操作系统的重要性。</p>
<h3 id="详细说明-65"><a href="#详细说明-65" class="headerlink" title="详细说明"></a><strong>详细说明</strong></h3><ul>
<li><strong>重要性</strong>：<ul>
<li><strong>隔离性</strong>：通过独立地址空间保护进程。例如，Linux 防止进程 A 访问进程 B 的内存。</li>
<li><strong>效率</strong>：分页和交换支持多任务。例如，Windows 运行多个大型应用程序。</li>
<li><strong>灵活性</strong>：透明地址空间简化开发。例如，C 程序无需关心物理内存。</li>
</ul>
</li>
<li><strong>现代优化</strong>：<ul>
<li><strong>TLB</strong>：缓存 PTE，减少查询延迟。</li>
<li><strong>多级页表</strong>：节省内存，支持大地址空间。</li>
<li><strong>大页</strong>：降低 TLB 压力。</li>
</ul>
</li>
<li><strong>挑战</strong>：页错误和抖动需优化。例如，Linux 的 kswapd 和 OOM 机制管理内存压力。</li>
<li><strong>实际 application</strong>：云服务器依赖虚拟内存支持高并发虚拟机。</li>
</ul>
<p><strong>思考问题</strong>：</p>
<ul>
<li>虚拟内存如何支持容器技术（如 Docker）？</li>
<li>未来内存虚拟化技术可能如何演进？</li>
</ul>
<p><strong>参考资料</strong>：</p>
<ul>
<li>《Operating Systems: Three Easy Pieces》完整版。</li>
<li>Linux 内核源代码（mm&#x2F; 目录）。</li>
</ul>
<hr>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><p>第 12-24 章全面介绍了内存虚拟化的核心概念，从地址空间抽象到页面替换策略：</p>
<ul>
<li><strong>地址空间</strong>：提供透明性、效率和保护。</li>
<li><strong>分页和分段</strong>：支持灵活分配和隔离。</li>
<li><strong>TLB</strong>：优化地址转换性能。</li>
<li><strong>交换和替换</strong>：扩展内存，优化缓存。</li>
<li><strong>VAX&#x2F;VMS</strong>：展示复杂实现，影响现代系统。</li>
</ul>
<p>这些机制是现代操作系统的基石，广泛应用于 Linux、Windows 等。例如，Linux 的 4 级页表和 TLB 缓存支持高效内存管理，满足高性能需求。理解这些内容有助于掌握操作系统设计和优化。</p>
<p><strong>参考资料</strong>：</p>
<ul>
<li>《Operating Systems: Three Easy Pieces》 by Arpaci-Dusseau。</li>
<li>Linux 内核文档（内存管理）。</li>
<li>Intel&#x2F;ARM 架构手册。</li>
</ul>
<hr>

        </div>

        
            <section class="post-copyright">
                
                    <p class="copyright-item">
                        <span>Author:</span>
                        <span>bocchi</span>
                    </p>
                
                
                    <p class="copyright-item">
                        <span>Permalink:</span>
                        <span><a href="http://example.com/2025/06/09/Memery%20Virtualization/">http://example.com/2025/06/09/Memery%20Virtualization/</a></span>
                    </p>
                
                
                    <p class="copyright-item">
                        <span>License:</span>
                        <span>Copyright (c) 2019 <a target="_blank" rel="noopener" href="http://creativecommons.org/licenses/by-nc/4.0/">CC-BY-NC-4.0</a> LICENSE</span>
                    </p>
                
                
                     <p class="copyright-item">
                         <span>Slogan:</span>
                         <span>Do you believe in <strong>DESTINY</strong>?</span>
                     </p>
                

            </section>
        
        <section class="post-tags">
            <div>
                <span>Tag(s):</span>
                <span class="tag">
                    
                    
                        <a href="/tags/Operate-System/"># Operate System</a>
                    
                        
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">back</a>
                <span>· </span>
                <a href="/">home</a>
            </div>
        </section>
        <section class="post-nav">
            
                <a class="prev" rel="prev" href="/2025/06/09/Persistence/">Persistence</a>
            
            
            <a class="next" rel="next" href="/2025/06/09/CPU%20Virtualization/">CPU Virtualization</a>
            
        </section>


    </article>
</div>

            </div>
            <footer id="footer" class="footer">
    <div class="copyright">
        <span>© bocchi | Powered by <a href="https://hexo.io" target="_blank">Hexo</a> & <a href="https://github.com/Siricee/hexo-theme-Chic" target="_blank">Chic</a></span>
    </div>
</footer>

    </div>
</body>

</html>